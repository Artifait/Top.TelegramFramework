
# Документация по архитектуре фреймворка для Telegram-ботов

Данная документация описывает архитектуру фреймворка для Telegram-ботов, предназначенного для обработки сложных сценариев диалога с возможностью изоляции сессий для каждого пользователя. Фреймворк построен на основе модульности, где логика диалога разбита на сценарии, составные блоки (CompositeBlock) и простые блоки (SimpleBlock). Состояние каждого пользователя сохраняется в базе данных через EF Core с SQLite.

---

## Содержание

1. [Основные концепции](#основные-концепции)
2. [Компоненты архитектуры](#компоненты-архитектуры)
   - [CompositeBlock (Составной блок)](#compositeblock-составной-блок)
   - [SimpleBlock (Простой блок)](#simpleblock-простой-блок)
   - [UserState и связанные классы](#userstate-и-связанные-классы)
   - [Scenario и ScenarioSelector](#scenario-и-scenarioselector)
   - [BotEngine – центральный обработчик сообщений](#botengine-–-центральный-обработчик-сообщений)
3. [Связи между классами](#связи-между-классами)
4. [Пример использования в точке входа (Program.cs)](#пример-использования-в-точке-входа-programcs)
5. [Замечания по клонированию блоков](#замечания-по-клонированию-блоков)

---

## Основные концепции

- **Модульность и изоляция:**  
  Логика диалога разделена на сценарии и составные блоки. Каждая сессия пользователя имеет собственное состояние, что позволяет обрабатывать одновременно множество пользователей без конфликтов.

- **Сценарий:**  
  Сценарий представляет собой контейнер для одного или нескольких составных блоков. Он отвечает за логику диалога и выбор стартового блока. Каждый сценарий имеет уникальный идентификатор.

- **Составной блок (CompositeBlock):**  
  Представляет отдельный этап диалога. Содержит один или несколько простых блоков, управляет внутренним состоянием (InternalState) и реализует методы:
  - `EnterAsync` – вызывается при переходе к блоку.
  - `HandleAsync` – обрабатывает входящие сообщения.
  - `OnEnd` – вызывается при завершении работы блока.
  
  Для обеспечения изоляции состояния каждого пользователя блоки должны быть клонируемыми через метод `Clone`.

- **Простой блок (SimpleBlock<TResponse>):**  
  Легковесный компонент для обработки конкретного ввода пользователя с помощью делегатов:
  - **ValidatorDelegate** – проверка корректности ввода.
  - **HandlerDelegate** – обработка сообщения и получение результата.

- **Состояние пользователя (UserState):**  
  Содержит информацию о текущем блоке сценария, внутреннем состоянии блока и дополнительном контексте (данные, переданные от предыдущего блока). Состояние сериализуется и сохраняется в базе данных с использованием EF Core (SQLite).

- **ScenarioSelector:**  
  Позволяет динамически выбирать сценарий для пользователя на основе условий (предикатов). Если для chatId не найдено подходящего сценария, возвращается сценарий по умолчанию.

- **BotEngine:**  
  Центральный компонент, объединяющий обработку входящих сообщений, управление состоянием пользователя и логику сценариев.

---

## Компоненты архитектуры

### CompositeBlock (Составной блок)

**Описание:**  
Абстрактный класс, описывающий этап диалога. Реализует методы для входа в блок, обработки сообщений и завершения работы.  
**Основные свойства и методы:**
- `string BlockId { get; }` – идентификатор блока.
- `Dictionary<string, object> InternalState` – внутреннее состояние блока.
- `ApplyState(Dictionary<string, object> state)` – инициализация внутреннего состояния.
- `CaptureState()` – захват текущего состояния для сохранения.
- `Task EnterAsync(BlockExecutionContext context, ITelegramBotClient bot, CancellationToken ct)` – вход в блок.
- `Task<CompositeBlockResult> HandleAsync(Message message, BlockExecutionContext context, ITelegramBotClient bot, CancellationToken ct)` – обработка сообщения.
- `void OnEnd()` – завершающая логика блока.
- `CompositeBlock Clone()` – создание независимой копии блока (важно для изоляции сессий).

---

### CompositeBlockResult

**Описание:**  
Класс, инкапсулирующий результат работы составного блока.  
**Свойства:**
- `IsError` – возникла ли ошибка.
- `IsEnd` – завершение работы блока.
- `IsContinue` – продолжение диалога.
- `ErrorMessage` – сообщение об ошибке.
- `Data` – дополнительные данные, передаваемые между блоками.

Методы-фабрики:
- `Error(string message, Dictionary<string, object> data = null)`
- `End(Dictionary<string, object> data = null)`
- `Continue(Dictionary<string, object> data = null)`

---

### SimpleBlock (Простой блок)

**Описание:**  
Компонент для обработки конкретного ввода пользователя.  
**Основные элементы:**
- **ValidatorDelegate:** `bool ValidatorDelegate(string userMessage, out string errorMessage)`
- **HandlerDelegate:** `TResponse HandlerDelegate<TResponse>(string userMessage)`
- Метод `ProcessAsync` для проверки и обработки входящего сообщения.

---

### UserState и связанные классы

**UserStateEntity:**  
Сущность EF Core, представляющая состояние пользователя в базе данных.  
**Основные свойства:**
- `ChatId` – идентификатор чата.
- `ScenarioId` – идентификатор сценария.
- `StateJson` – сериализованное состояние (объект UserState).

**UserState:**  
Класс, представляющий состояние сессии пользователя.  
**Свойства:**
- `CurrentCompositeBlockId` – идентификатор текущего блока.
- `CompositeBlockState` – внутреннее состояние блока.
- `Context` – дополнительный контекст, передаваемый между блоками.

Методы:
- `Serialize()` – сериализация в JSON.
- `Deserialize(string json)` – восстановление из JSON.

**UserStateContext:**  
Контекст базы данных (EF Core) с настройкой SQLite.  
**Свойства:**
- `DbSet<UserStateEntity> UserStates`

**UserStateRepository:**  
Репозиторий для взаимодействия с базой данных.  
Методы:
- `GetUserStateAsync(long chatId, string scenarioId)`
- `SaveOrUpdateUserStateAsync(long chatId, string scenarioId, UserState state)`
- `DeleteUserStateAsync(long chatId, string scenarioId)`

---

### Scenario и ScenarioSelector

**Scenario:**  
Контейнер для составных блоков, представляющий один сценарий диалога.  
**Основные свойства и методы:**
- `string ScenarioId` – уникальный идентификатор сценария.
- `RegisterBlock(CompositeBlock block)` – регистрация блока в сценарии.
- `CompositeBlock InitialBlock` – стартовый блок сценария.
- `GetBlock(string id)` – возвращает клон запрошенного блока, обеспечивая независимость состояний.

**ScenarioSelector:**  
Отвечает за выбор сценария для пользователя.  
Методы:
- `Register(Scenario scenario, Func<long, bool> condition)` – регистрация сценария с условием.
- `SetDefault(Scenario scenario)` – установка сценария по умолчанию.
- `GetScenarioForUser(long chatId)` – выбор сценария для конкретного пользователя по его chatId.

---

### BotEngine – центральный обработчик сообщений

**Описание:**  
Класс, объединяющий обработку входящих обновлений от Telegram, управление состоянием пользователя и логику сценариев.  
**Основные шаги обработки:**
1. Получение входящего обновления (Update).
2. Определение сценария для пользователя с помощью `ScenarioSelector`.
3. Загрузка сохранённого состояния пользователя из базы (UserStateRepository).
4. Получение нужного блока:
   - Если состояние отсутствует, используется стартовый блок (`InitialBlock`).
   - Если состояние есть, блок восстанавливается по его идентификатору и применяется сохранённое внутреннее состояние.
5. Вызов метода `EnterAsync` (если необходимо) и обработка сообщения через `HandleAsync`.
6. В зависимости от результата (`CompositeBlockResult`):
   - Отправка сообщения об ошибке.
   - Завершение диалога и удаление сохранённого состояния.
   - Продолжение диалога и обновление состояния пользователя.

---

## Связи между классами

- **BotEngine ↔ ScenarioSelector:**  
  BotEngine использует ScenarioSelector для определения, какой сценарий применять для конкретного пользователя (по chatId).

- **Scenario ↔ CompositeBlock:**  
  Каждый Scenario содержит набор зарегистрированных CompositeBlock. Метод `GetBlock(string id)` возвращает клон блока, чтобы обеспечить изоляцию состояния для каждого пользователя.

- **CompositeBlock ↔ SimpleBlock:**  
  CompositeBlock может включать один или несколько простых блоков для обработки конкретного ввода. SimpleBlock использует делегаты для валидации и обработки сообщений.

- **CompositeBlock ↔ UserState:**  
  После обработки сообщения CompositeBlock захватывает своё состояние через `CaptureState()` для сохранения в объекте UserState. При восстановлении состояния, метод `ApplyState(Dictionary<string, object> state)` применяется к блоку.

- **UserStateRepository ↔ UserStateContext:**  
  UserStateRepository взаимодействует с базой данных через UserStateContext для сохранения, обновления и удаления состояния пользователя.

- **BotEngine ↔ UserStateRepository:**  
  BotEngine загружает текущее состояние пользователя из репозитория, обновляет его при продолжении диалога или удаляет при завершении.

---

## Пример использования в точке входа (Program.cs)

В точке входа происходит:
1. Инициализация клиента Telegram Bot.
2. Настройка EF Core с SQLite и создание базы данных.
3. Создание и регистрация сценариев, а также настройка ScenarioSelector.
4. Создание экземпляра BotEngine с передачей ScenarioSelector и репозитория состояния.
5. Запуск механизма получения обновлений (polling) и обработка входящих сообщений через BotEngine.

---

## Замечания по клонированию блоков

Поскольку один и тот же сценарий может использоваться для множества пользователей, важно, чтобы каждый пользователь имел **собственную копию** CompositeBlock. Для этого:
- В базовом классе CompositeBlock объявлен абстрактный метод `Clone()`.
- Конкретные реализации (например, `WelcomeBlock`) должны переопределять метод `Clone()`, возвращая новый экземпляр блока.
- Метод `Scenario.GetBlock(string id)` теперь возвращает клон, а не оригинальный экземпляр, тем самым предотвращая разделение состояния между пользователями.

---

## Итог

Архитектура фреймворка построена на четком разделении ответственности:
- **Сценарии** управляют логикой диалога и содержат набор блоков.
- **CompositeBlock** реализуют этапы диалога, а их клонирование гарантирует независимость сессий.
- **SimpleBlock** предоставляет легковесные компоненты для валидации и обработки конкретного ввода.
- **UserState** и связанные классы обеспечивают сохранение и восстановление состояния между сообщениями.
- **BotEngine** объединяет всю логику обработки обновлений от Telegram и взаимодействия с пользователями.

Такая архитектура позволяет масштабировать бота, обрабатывать множество пользователей одновременно и легко добавлять новые сценарии и блоки для расширения функциональности.
